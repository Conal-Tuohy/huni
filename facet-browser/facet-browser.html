<!doctype html>
<html lang="en" ng-app>	
	<head>
		<title>Facet Browser</title>
		
		<!-- AngularJS app framework -->
		<script src="lib/angular/angular.js"></script>
		
		<!-- The generic faceted browser -->
		<script type="text/javascript" id="facet-browser-engine">
		//<![CDATA[
		// Facet-Browser library
		
		// A model for querying RDF data using SPARQL Property Paths as facets (in the library science sense). 
		
		// A Facet Browser Controller corresponds to a search session.
		// It adds a collection of facets, and some search results to the scope.
		function FacetBrowserController($scope, $http) {
			var facets = {};
			$scope.changed = false;
			$scope.facets = facets;
			$scope.modelUpdated = function() {
				$scope.changed = true;
			}
			$scope.itemQuery = "";

			$scope.refresh = function() {
			
				// record the currently selected values of each facet as the constraints of each facet
				for (var facetName in $scope.facets) {
					var facet = $scope.facets[facetName];
					facet.constraints.length = 0;
					for (var v = 0; v < facet.values.length; v++) {
						// add this value as a constraint on this facet, if the value is selected
						var facetValue = facet.values[v];
						if (facetValue.selected) {
							facet.constraints.push(facetValue.value);
						}
					}
				}
				// now we have got the constraints, we can execute the queries
				$scope.executeQuery();
			}				

			$scope.executeQuery = function() {
				// compute and execute queries
				var freeTextCriterion = "{?item (<http://xmlns.com/foaf/0.1/name>|<http://www.w3.org/2004/02/skos/core#prefLabel>) ?text. "
				freeTextCriterion = freeTextCriterion + "FILTER(CONTAINS(LCASE(?text), 'mason'))}"
				
				// results
				var itemQuery = "SELECT distinct(?item as ?hit) ?name WHERE {";
				for (var facetName in $scope.facets) {
					// set any constraints on this facet
					var facet = $scope.facets[facetName];
					// keep track of whether we've constrained the facet yet
					var facetConstrained = false;
					for (var c = 0; c < facet.constraints.length; c++) {
						var constraint = facet.constraints[c];
						if (facetConstrained) {
							// facet already had a constraint, so we have to expand it to include this one
							itemQuery = itemQuery + " UNION ";
						}
						itemQuery = itemQuery + "{?item " + facet.propertyPath + " " + constraint + "}";
						facetConstrained = true;
						
					}
				}
				itemQuery = itemQuery + " optional {?item <http://xmlns.com/foaf/0.1/lastName> ?name}}";
				$scope.itemQuery = itemQuery;
				$scope.itemQueryURI = "http://corbicula.huni.net.au/dataset/query?output=xml&stylesheet=%2Fxslt%2Fxml-to-html.xsl&query=" + encodeURIComponent(itemQuery);
				
				var facetValuesQuery = "SELECT ?facetName ?facetValue ?facetValueLabel (COUNT(DISTINCT(?item)) AS ?facetValueCount)\nWHERE {\n";

				// QAZ any non-facet query constraints:
				//facetValuesQuery = facetValuesQuery + "?item a <http://erlangen-crm.org/current/E21_Person> . ";
				// filter (contains(lcase(str(?occupation)), lcase('physicist')))
				//facetValuesQuery = facetValuesQuery + freeTextCriterion;

				var hasPrecedingFacet = false; // the first facet has no preceding facet
				for (var facetName in $scope.facets) {
					// select values of this facet which match the constraints of the other facets
					var facet = $scope.facets[facetName];
					if (hasPrecedingFacet) {
						facetValuesQuery = facetValuesQuery + "\tUNION\n";
					}
					hasPrecedingFacet = true;
					facetValuesQuery = facetValuesQuery + "\t{\n\t\tBIND('" + facet.name + "' as ?facetName)\n";
					facetValuesQuery = facetValuesQuery + "\t\t?item " + facet.propertyPath  + " ?facetValue.\n";
					// constrain values by the other facet selections
					//facetValuesQuery = facetValuesQuery + "{"; 
					var facetCounter = 0;
					for (var otherFacetName in $scope.facets) {
						if (otherFacetName != facetName) {
							otherFacet = $scope.facets[otherFacetName];
							if (otherFacet.constraints.length > 0) {
								facetCounter = facetCounter + 1;
								// the value counts for a facet are computed based on the selected constraints of all OTHER facets, excluding the facet itself
								facetValuesQuery = facetValuesQuery + "\t\t?item " + otherFacet.propertyPath + " ?facet" + facetCounter + "Value.\n\t\tFILTER(?facet" + facetCounter + "Value IN (\n\t\t\t";
								var facetConstrained = false;
								for (var c = 0; c < otherFacet.constraints.length; c++) {
									var constraint = otherFacet.constraints[c];
									if (facetConstrained) {
										// adding a constraint to a non-null list of constraints, so need a comma
										facetValuesQuery = facetValuesQuery + ",\n\t\t\t";
									}
									facetValuesQuery = facetValuesQuery + constraint;
									facetConstrained = true;
								}
								facetValuesQuery = facetValuesQuery + "\n\t\t))\n";
							}
						}
					}
					facetValuesQuery = facetValuesQuery + "\t}\n";
				}
				// QAZ assumptions about appropriate facet value labels
				facetValuesQuery = facetValuesQuery + "\tOPTIONAL {?facetValue <http://www.w3.org/2004/02/skos/core#prefLabel> ?facetValueLabel}\n";
				facetValuesQuery = facetValuesQuery + "\tOPTIONAL {?facetValue <http://xmlns.com/foaf/0.1/name> ?facetValueLabel}\n";
				facetValuesQuery = facetValuesQuery + "}\n";
				facetValuesQuery = facetValuesQuery + "GROUP BY ?facetName ?facetValue ?facetValueLabel\n";
				facetValuesQuery = facetValuesQuery + "ORDER BY ?facetName DESC(?facetValueCount)";
				
				// update model properties with computed query
				// QAZ replace this: make http request, parse results, repopulate facet model
				var sparqlEndpoint = "http://corbicula.huni.net.au/dataset/query";
				$scope.facetValuesQuery = facetValuesQuery;
				// Specify media types for the SPARQL query and the query results
				var config = {
					"headers": {
						"Accept": "application/sparql-results+json",
						"Content-Type": "application/sparql-query"
					}
				};
				$http.post(sparqlEndpoint, $scope.facetValuesQuery, config).
					success(
						function(data, status, headers, config) {
							// this callback will be called asynchronously
							// when the response is available
							$scope.facetValuesQueryResponse = data.results.bindings;
							
							// rebuild the facet data model
							var currentFacet;
							// process the list of facet values
							for (var facetName in $scope.facets) {
								// discard the facet's old values
								var facet = $scope.facets[facetName];
								//var staleValuesCount = facet.values.length;
								//for (v = 0; v < staleValuesCount; v++) {
								//	facet.values.pop();
								//}
//								facet.values = new Array();
								facet.values.length = 0;
							}
							for (var i = 0; i < data.results.bindings.length; i++) {
								var binding = data.results.bindings[i];
								var facetName = binding.facetName.value;
								var facetValueValue;
								// convert facet value into a SPARQL expression
								if (binding.facetValue.type = "uri") {
									facetValueValue = "<" + binding.facetValue.value + ">";
								} else {
									// QAZ handle facet values which are not URIs
								}
								var facetValueLabel;
								if (binding.facetValueLabel) {
									facetValueLabel = binding.facetValueLabel.value; // QAZ handle non-string values or missing values
								} else {
									facetValueLabel = binding.facetValue.value;
								}
								var facetValueCount = binding.facetValueCount.value;
								
								currentFacet = $scope.facets[facetName];
								var facetValueSelected = false;
								for (v = 0; v < currentFacet.constraints.length; v++) {
									if (facetValueValue == currentFacet.constraints[v]) {
										facetValueSelected = true;
									}
								}
								var facetValue = new FacetValue(facetValueValue, facetValueLabel, facetValueCount, facetValueSelected);
								currentFacet.values.push(facetValue);
								
							}
						}
					).
					error(
						function(data, status, headers, config) {
							// called asynchronously if an error occurs
							// or server returns response with an error status.
							alert('Error reading facets from server');
						}
					);
			};
			
			// add some example facets - replace with a SPARQL query
			var occupationFacet = new Facet("Occupation/Role",  "<http://erlangen-crm.org/current/P2_has_type>");
			var groupFacet = new Facet("Groups", "<http://erlangen-crm.org/current/P107i_is_current_or_former_member_of>");
			var typeFacet = new Facet("Type", "a");
			
			facets[occupationFacet.name] = occupationFacet;
			facets[groupFacet.name] = groupFacet;
			facets[typeFacet.name] = typeFacet;
			
			// set initial constraints
			occupationFacet.constraints.push("<http://corbicula.huni.net.au/data/eoas/occupation/Information_technologist>");
			occupationFacet.constraints.push("<http://corbicula.huni.net.au/data/eoas/occupation/Electrical_engineer>");
			
			groupFacet.constraints.push("<http://corbicula.huni.net.au/data/eoas/A000219>");
			groupFacet.constraints.push("<http://corbicula.huni.net.au/data/eoas/A000746>");

			typeFacet.constraints.push("<http://erlangen-crm.org/current/E21_Person>");
			
			$scope.executeQuery();
		};
		
		// A facet is a named SPARQL Property Path, along with a set of values, each value either selected or 
		// unselected, and each value with a count, representing the number of search hits which have that value.
		// A facet produces constraints for queries.
		// => search results query whose results all match the property path.
		// => browse values query whose results are all the possible values of the property path,
			// each with a count of the number of times each value occurs

		
		function Facet(name, propertyPath) {
			this.name = name;
			this.propertyPath = propertyPath;
			this.values = new Array();
			this.constraints = new Array();
		}
		
//		function FacetValue(value, name, count, selected) {
		function FacetValue(value, name, count, selected) {
			this.value = value;
			this.name = name;
			this.count = count;
			this.selected = selected;
		}

		//]]>
		</script>
		<style type="text/css">
			body {
				font-family: sans-serif;
			}
			form#facets {
				float:left; width: 30%;
			}
			form#facets h2 {
				font-size: 10pt;
				font-weight: bold;
			}
			form#facets li {
				font-size: 9pt;
			}
			#results {
				float:right;  
				height: 30em;
				width: 65%;
			}
			form#facets ul {
				list-style: none;
				margin-left: 0;
				padding-left: 0;
				text-indent: 0;
			}
			div.debug {
				font-size: small;
				border-style: solid;
				border-color: black;
				border-top-width: 1pt;
				border-bottom-width: 2pt;
				border-left-width: 1pt;
				border-right-width: 2pt;
				background-color: yellow;
				padding: 1em;
				margin: 1em;
				width: 20em;
				float: right;
			}
		</style>
	</head>
	<body ng-controller="FacetBrowserController">
		<h1>Facet Browser</h1>
		<div class="debug">
			<p>In this demo, the browser starts with the following constraints already set: </p>
			<ul>
				<li>Occupation is either Information Technologist or Electrical Engineer; and</li>
				<li>Group is either CSIRO Division of Radiophysics or CSIRO Division of Telecommunications and Industrial Physics</li>
				<li>Type is Person</li>
			</ul>
		</div>
		<!--<p>{{'OK'}}</p>-->
		<form id="facets" name="facet-form">
			<ul>
				<li ng-repeat="facet in facets">
					<h2>{{facet.name}}</h2>
					<ul>
						<li ng-repeat="value in facet.values">
							{{value.name}} ({{value.count}})
							<input type="checkbox" ng-model="value.selected" ng-change="refresh()"/>
						</li>
					</ul>
				</li>
			</ul>
		</form>
		<iframe id="results" ng-src="{{itemQueryURI}}"></iframe>
		<div style="clear:both;">
			<!--
			<p>Item query: <a ng-href="{{itemQueryURI}}">{{itemQuery}}</a></p>
			<p>Facet values query: {{facetValuesQuery}}</p>
			
			<p>Facet values query response: 
			{{facetValuesQueryResponse}}.</p>
			-->
		</div>
	</body>
</html>
